---
layout: post
title: "POST 요청 시, useSWRMutation을 사용하는 이유와 그 필요성"
date: 2024-12-03 12:28:07 +0900
tags: react, javascript
---


**useSWRMutation**은 주로 POST와 같은 상태 변경 요청을 다룰 때 유용하게 사용된다. 하지만 useSWR의 기본적인 동작 방식과는 차이가 있어서 왜 POST 요청을 처리할 때 useSWRMutation을 사용할지에 대해 고민이 될 수 있다. 이 글에서는 useSWRMutation을 사용해야 하는 이유와 그렇지 않은 경우를 비교해 보자.

### useSWRMutation 사용 시의 특징
useSWRMutation은 trigger 함수를 이용해 수동으로 요청을 트리거해야 하고, 상태를 공유하지 않으며 기본적인 GET 요청처럼 자동으로 캐시를 갱신하거나 데이터를 관리하지 않는다. 그럼에도 불구하고 useSWRMutation을 사용하는 이유가 있을까?

### GET 요청과 useSWR의 차이점
useSWR은 GET 요청에 최적화되어 있으며, 이 요청은 데이터를 캐시하고, mutate를 사용해 낙관적 업데이트와 같은 즉각적인 데이터 업데이트가 가능하다. 즉, GET 요청은 자동으로 상태를 관리하고 캐시를 갱신하는 방식으로 설계되어 있어 mutate를 호출하면 즉시 업데이트가 가능하다.

반면, POST 요청은 상태 변경을 의미하며, 기본적으로 GET처럼 캐시를 관리하거나 상태를 자동으로 갱신하지 않기 때문에 useSWRMutation이 필요하다. 하지만 **useSWRMutation**은 두 가지 큰 단점이 존재한다:

수동으로 trigger로 요청을 보내야 한다는 점.
상태를 공유하지 않으므로, GET 요청처럼 즉각적인 업데이트가 어려운 점.
useSWRMutation을 사용하는 이유
그럼에도 불구하고 **useSWRMutation**을 사용하면 다음과 같은 장점이 있다:

### 비동기 작업의 상태 추적
isMutating, onSuccess, onError와 같은 상태를 활용하여 비동기 작업의 진행 상태를 바로 알 수 있다. 예를 들어, 로딩 상태를 처리하거나 에러 메시지를 표시할 수 있어, 사용자 경험을 개선하는 데 유용하다.

### 후속 작업 처리
onSuccess나 onError를 통해 요청이 성공하거나 실패했을 때 추가 작업을 쉽게 처리할 수 있다. 예를 들어, 거래가 성공하면 거래 내역을 업데이트하거나, 실패 시에는 에러 메시지를 보여주는 작업을 바로 처리할 수 있다.

## GET 요청 vs POST 요청 관리 방식

### GET 요청
커스텀 훅으로 관리하는 것이 좋다. mutate를 어디서든 호출해 데이터의 **즉각적인 업데이트(낙관적 업데이트)**가 가능하기 때문이다.
낙관적 업데이트는 UI에서 사용자에게 빠르게 반영된 것처럼 보이게 하여, 더 빠른 반응성을 제공할 수 있다.

### POST 요청
커스텀 훅으로 관리하지 않아 되고, 상황에 따라 결정하면 된다. 
장점이 크게 느껴지지 않았다. POST 요청의 경우, 후속 작업(예: 거래 성공 후 데이터 갱신, 에러 처리)을 useSWRMutation의 onSuccess와 onError에서 처리할 수 있기 때문에, 별도로 커스텀 훅으로 만들지 않고 상태 관리가 가능하다.
불필요한 복잡성을 피하고, onSuccess와 onError에서 필요한 후속 작업만 처리하는 것이 더 효율적이다.

### 결론
GET 요청은 useSWR과 mutate를 잘 활용하여 상태를 관리하고 업데이트하는 것이 유리하다.
POST 요청은 상태 변경을 직접 다루므로 useSWRMutation을 통해 후속 작업을 처리하고, 상태 추적 및 관리에 유리하다.
POST 요청을 커스텀 훅으로 관리하는 것에는 메리트가 크지는 않다. 그래도 모든 데이터 fetch를 커스텀 훅에서 관리하는 통일성이 있으므로 상황에 따라 선택하면 된다.
