---
layout: post
title: "연오의 파이썬 공부 6"
date: 2022-07-29 22:20:13 +0900
tags: yeono-python
---

### 시퀀스 조작 메서드

(시퀀스는 데이터에 순서를 붙여 나열한 것이다.)
시퀀스의 내용을 수정하는 메서드이기 때문에 튜플 등 불변 시퀀스에는 적용할 수 없으며, 가변 시퀀스인 리스트에 주로 사용된다.

`append()`는 요소 하나를 추가하는 것이고, `extend()`는 시퀀스를 추가하는 것이기에 `append([100, 200])`을 하면, 요소 두 개가 들어가는 게 아니라, `[100, 200]` 리스트 하나가 들어간다.

요소 삭제: `pop()`은 마지막 요소 하나를 꺼내서 ‘확인하고’ 버린다. 그래서 `remove()`와 달리 실행하면 삭제될 요소를 출력하고 지움. `remove()`는 지울 값을 지정해 주지 않으면 오류가 발생한다.

튜플은 다양한 데이터를 담을 수 있지만, 내용을 변경할 수는 없는 시퀀스: 내용이 불변인 요일 같은 데이터 저장에 어울린다.

튜플 표현 방법:
빈 튜플: `()`
요소가 하나인 튜플 `(1,)` 또는 `1,` (원자 데이터와 구별 위해서 콤마 꼭 붙임)
요소가 둘 이상인 튜플 `(1, 2)` 또는 `1, 2`

튜플 뒤에 시퀀스를 연결하는 연산자를 제공하기는 하나, 튜플은 불변 시퀀스이므로 원본이 변하는 건 아니다.

### 레인지

레인지를 사용해 수열을 간단한 함수 호출로 만들 수 있다.

레인지의 내용은 바로 출력되지 않는다. 레인지는 계산하기 위한 규칙만 갖고 있고 요소 자체는 갖고 있지 못하기 때문이다. 필요한 시점에 만듦.

엄청 넓은 레인지를 리스트나 튜플로 변환 시 메모리 오류가 난다. 그렇지만 그것의 요소 하나를 읽는 것은 가능. 필요한 시점에 ‘계산’하기 때문!

레인지는 요소를 직접 갖지 않으므로 요소를 수정하는 것도 당연히 불가능하다. 불변 데이터.

> `range(0, 100, 2)[10:20:2]`가 바로 이해되지는 않았는데,
> range의 등차수열의 범위와 공차를 다시 계산하여, 규칙을 가진 거 같다. 20부터 40미만까지 4씩 증가하는 등차수열이라고

불변 데이터 대입 연산은 지원하지 않는다.

대입하려면 리스트로 바꿔서

문자열은 시퀀스, 불변 데이터이다.

문자열 그 자체도 시퀀스이기 때문에, 개별요소 사이에 구분자를 끼워 넣을 수 있다.

연습문제 5-1

```python
multiples_of_8_list = list(range(0, 100, 8))

print(multiples_of_8_list)
```

연습문제 5-2

```python
def center(sequence):
   """시퀀스를 하나 입력받아, 그 시퀀스의 가운데 요소를 반환한다."""
   return sequence[int(len(sequence) / 2)]


print(center(['가', '나', '다', '라', '마']))
print(center([2, 4, 8, 16, 32]))


# 나는 중간값을 계산하기 위해서 int(len(sequence) / 2)로 했는데, 모범답안에는 len(sequence) // 2로 되어 있다. 몫 연산자가 쓸데가 별로 없다고 생각했는데.. 이렇게 쓸 수 있구나.
```

연습문제 5-3

```python
def mirror(sequence):
   """시퀀스(sequence)를 하나 입력 받아서 그 시퀀스를 뒤집은 시퀀스를 원본에 덧붙여 반환한다.
   단, 원본 시퀀스의 마지막 요소는 덧붙어지 않는다."""
   reversed_sequence = sequence[::-1]
   sequence.pop()
   return sequence + reversed_sequence


print(mirror([1, 2, 3]))
print(mirror(['가', '져', '가', '라']))

# 나는 원본의 마지막 요소를 pop()으로 없애 버렸는데, 모범 답안에서는 마지막 요소 없이 뒤집은 sequence를 구한다.
# reversed_sequence = sequence[-2::-1]. 마지막은 -1이니까, 마지막을 제외하려면 -2.
```

연습문제 5-4

```python
def minmax(sequence):
   """전달받은 시퀀스(sequence)의 최솟값과 최댓값을 리스트에 담아 반환한다."""

   return [min(sequence), max(sequence)]


print(minmax([92, -21, 0, 104, 51, 76, -92]))
print(minmax(['파', '이', '썬', '프', '로', '그', '래', '밍']))
print(minmax('파이썬프로그래밍'))  # 문자열도 시퀀스
```

연습문제 5-5

```python
def mean(sequence):
   """시퀀스(sequence) 하나를 입력 받아 시퀀스 내 모든 요소의 산술평균을 반환한다.
   단, 빈 시퀀스는 입력하지 않기로 약속한다."""

   return sum(sequence) / len(sequence)


print(mean([92, -21, 0, 104, 51, 76, -92]))
```

연습문제 5-6

```python
stations = []
stations.append('서울')  # ['서울']
stations += (['수원', '대전'])  # ['서울', '수원', 대전']
stations.extend(['밀양', '부산'])  # ['서울', '수원', 대전', '밀양', '부산']
stations.insert(3, '동대구')  # ['서울', '수원', 대전', '동대구', '밀양', '부산']

print(stations)  # 예상: ['서울', '수원', 대전', '동대구', '밀양', '부산']
print(stations.pop())  # 예상: ['서울', '수원', 대전', '동대구', '밀양']
print(stations.remove('수원'))  # 예상: ['서울', 대전', '동대구', '밀양']
print(stations)  # 예상: ['서울', 대전', '동대구', '밀양']


# 오답노트: stations.pop()과 stations.remove('수원')을 출력하는 건데, list의 변화에만 중점을 두어 출력 값을 다르게 해석했다.
# pop()을 하면 마지막 요소인 '부산'이 없어지는 건 문제를 제대로 봤으면 알 수 있었을 거 같은데,
# remove()를 하면 None을 반환한다는 건 몰랐을 듯...
# 해설: remove() 메서드는 리스트에서 특정 요소를 찾아 제거하는데, 반환값은 없다. 함수의 반환값이 없으므로 None이 출력된다.
```

연습문제 5-7

```python
print(sum(range(0, 10_000, 2)))
```

연습문제 5-8

```python
print(list(range(0, 10))[::-1])

# range()를 오름차순으로 쓸 생각만 했다. 내림차순으로 하면 되는데...
# 모범답안: list(range(9, -1, -1))
```

연습문제 5-9

```python
def reverse(sequence):
   """시퀀스(sequence)를 입력받아 반대 순서로 뒤집어 반환한다."""
   return sequence[::-1]


print(reverse([10, 20, 30, 40]))
print(reverse(tuple('일월화수목금토')))
print(reverse(range(10)))
print(reverse('파이썬프로그래밍'))

# 슬라이싱 연산 자꾸 쓰는 거 같아서 뭔가 자신 없었지만 모범 답안과 일치함.
```

매핑: 이름 역할을 하는 데이터와 값 역할을 하는 데이터를 짝지어 관리하는 방법
데이터를 저장할 때 순서보다 좀 더 의미 있는 식별 방법이 필요하다면 매핑을 사용하는 것이 좋다.

파이썬의 매핑 컬렉션에는 사전, 기본값 사전 등이 있다.

키는 불변 데이터여야..
튜플에 가변 데이터가 들어 있을 때도 키로 쓸 수 없다.

사전에서 in은 ‘키’가 있는지 확인할 때 쓴다.

`get` 메서드를 쓰면 오류 없이 쓸 수 있다.
`update`는 키가 없으면, 추가도 해 줌.
지울 때는 `del` 명령어로… 왜 얘만 명령어일까

사전 하나로 덩어리를 저장. 그걸 여러 개 저장하려면? 몇 개가 될지 모르는 여러 개의 데이터를 관리할 때는 리스트를 사용하는 것이 좋다.

연습문제 5-10

```python
식재료별_칼로리 = {'밀가루': 364, '피망': 20.1, '올리브': 115, '돼지고기': 242.1}
print(식재료별_칼로리)
# 모범답안에서는 1g당 칼로리를 구했다. 이 문제에서는 100g당으로 해도 상관은 없었지만,
# 단위가 있는 데이터를 다룰 때는 신경을 쓰는 게 좋을 듯..



식재료별_칼로리 = {
   '밀가루': 364,
   '피망': 20.1,
   '올리브': 115,
   '돼지고기': 242.1,
}
```

연습문제 5-11

```python
def 칼로리(food_name, weight):
   """음식의 종류(food_name)와 섭취량(weight)을 매개변수에 전달받아 총 칼로리를 반환한다."""

   식재료별_칼로리 = {
       '밀가루': 364 / 100,
       '피망': 20.1 / 100,
       '올리브': 115 / 100,
       '돼지고기': 242.1 / 100,
   }

   return 식재료별_칼로리.get(food_name, 0) * weight


print(칼로리('돼지고기', 500))
print(칼로리('소고기', 300))


# 모범 답안에는 식재료별_칼로리 사전이 전역변수로 되어 있음.
```

연습문제 5-12

```python
식재료별_칼로리 = {
   '밀가루': 364 / 100,
   '피망': 20.1 / 100,
   '올리브': 115 / 100,
   '돼지고기': 242.1 / 100,
}

def 칼로리(food_name, weight):
   """음식의 종류(food_name)와 섭취량(weight)을 매개변수에 전달받아 총 칼로리를 반환한다."""

   return 식재료별_칼로리.get(food_name, 0) * weight


식재료별_칼로리['치즈'] = 402.5 / 100
print(칼로리('치즈', 100))
```

### 집합

a 컬렉션과 b 컬렉션 모두에 포함되어 있는 데이터(교집합) 등은 집합을 이용해서 구한다.
집합은 원소에 순서나 키를 붙여 관리하지 않는다. 동일한 원소는 하나만 가질 수 있다.

집합을 시퀀스로 바꾸거나 시퀀스를 집합으로 만들 수 있다. (집합은 시퀀스가 아님! => 시퀀스는 데이터에 순서를 붙여 나열한 것)

집합 이용해 중복 없애면 순서도 잃음.

집합은 소속 검사, 합집합, 교집합, 여집합, 차집합, 부분집합 검사 할 수 있다.

`remove()`는 `discard()`와 달리 찾는 요소가 없으면 오류가 발생.

연습문제 5-13

```python
모든_요일 = {'월', '화', '수', '목', '금', '토', '일'}
직장_요일 = {'월', '화', '수', '목', '금'}
휴식_요일 = {'토', '일'}

# 변수 이름이 별로인듯..
```

연습문제 5-14

```python
days = {'월', '화', '수', '목', '금', '토', '일'}
working_days = {'월', '화', '수', '목', '금'}
holidays = {'토', '일'}


def is_holiday(day):
   """요일을 입력받아 그 요일이 쉬는 날이면 True, 아니면 False를 반환한다."""

   return day in holidays


print(is_holiday('월'))
print(is_holiday('토'))
```

연습문제 5-15

```python
# 3의 배수 또는 4이 배수
multiple_3 = set(list(range(0, 1_000, 3)))
multiple_4 = set(list(range(0, 1_000, 4)))

print(len(multiple_4.union(multiple_3)))
```

연습문제 5-16

```python
# 3과 4의 공배수
multiple_3 = set(list(range(0, 1_000, 3)))
multiple_4 = set(list(range(0, 1_000, 4)))

print(len(multiple_4.intersection(multiple_3)))
```

연습문제 5-17

```python
# 3과 4의 차집합
multiple_3 = set(list(range(0, 1_000, 3)))
multiple_4 = set(list(range(0, 1_000, 4)))

print(len(multiple_3.difference(multiple_4)))
```
