---
layout: post
title: "React deep dive) 렌더링"
date: 2024-03-10 14:18:07 +0900
tags: deepdive
---

###### \<모던 리액트 Deep Dive\>의 내용을 제가 이해한 바로 다시 정리한 글입니다.

리액트의 렌더링은 모든 컴포넌트들이 자기가 가지고 있는 props와 state값을 기반으로 UI를 구성하고, 이를 통해 브라우저가 DOM 트리를 만드는 과정을 의미한다.

### 리렌더링이 일어나는 경우

1. 상태가 변경되는 경우: 클래스 컴포넌트의 `setState`나 함수 컴포넌트의 `useState()`에서 두 번째 배열 요소인 `setter`가 실행되는 경우
2. props가 변경되는 경우: 부모 컴포넌트로부터 받은 props가 달라질 경우 이를 사용하는 자식 컴포넌트에서도 변화가 일어나야 하므로
3. 부모 컴포넌트가 리렌더링되는 경우
4. 훅으로 관리되는 값이 변경될 때
5. Context API 사용 시, Context의 값이 변경되면 그 값을 사용하는 모든 컴포넌트들이 변경된다.
6. `forceUpdate`로 강제 리렌더링할 때
   7리스트 아이템 렌더링 시 key props가 변경될 경우: key props는 사실 모든 컴포넌트에서 사용 가능하고, 리액트는 key를 통해 각 요소를 식별한다. 만약 리스트 전체의 key만 존재하고 낱개 요소의 key가 존재하지 않는다면 이들을 식별을 할 수 없다. 그래서 리스트의 요소가 하나만 업데이트되어도 모두를 업데이트해야 한다. key props를 넣을 경우 이를 막을 수 있다.

### 렌더와 커밋

리액트의 렌더링은 렌더와 커밋 두 단계로 이루어진다.

렌더 단계: 컴포넌트를 렌더링하고 변경 사항을 계산하는 모든 작업. 이 단계에서 리액트는 컴포넌트 트리를 순회하면서 어떤 변경이 이루어져야 하는지를 파악하고, 실제 DOM에 적용할 변경 사항들을 계산한다. 이 과정에서는 실제 DOM에 바로 반영되지 않고, 리액트가 내부적으로 관리하는 메모리상의 트리(가상 DOM)에 반영된다.

커밋 단계: 렌더 단계의 변경 사항을 실제 DOM에 적용해 사용자에게 보여주는 과정이다.

그 후에는 이렇게 만들어진 모든 DOM 노드 및 인스턴스를 가리키도록 리액트 내부의 참조를 업데이트한다. 함수 컴포넌트에서는 `useLayoutEffect` 훅을 호출한다.

렌더 단계에서 변경 사항을 계산했는데 커밋할 필요가 없다면, 커밋 단계는 생략될 수 있다. 렌더 단계는 눈에 보이는 변경이 없어도 진행될 수 있는 것이다.

### 리렌더링 조건에 만족했을 때 일어나는 일

A - B - C - D 순서로 부모 자식 간의 관계를 이룬다고 해 보자. B에서 리렌더링 요건이 되면, B 컴포넌트의 리렌더링 작업이 렌더링 큐에 들어간다.

렌더링 큐는 웹 브라우저가 화면에 변경사항을 표시하기 위해 내부적으로 관리하는 대기열을 의미한다.
(태스크 큐는 비동기 작업을 위한 것이었음을 기억하자.)

D의 컴포넌트는 값이 업데이트되지 않는다고 가정해 보자. 그러더라도 B나 C가 업데이트되면 리렌더링된다. 그러므로 이럴 때는 메모이제이션을 해 주면 좋다.

```js
export default function A() {
  return (
    <div className="App">
      <h1>Hello React!</h1>
      <B />
    </div>
  );
}

function B() {
  const [counter, setCoutner] = useState(0);

  function handleButtonClick() {
    setCoutner((previous) => previous + 1);
  }

  return (
    <>
      <label>
        <C number={counter} />
      </label>
      <button onClick={handleButtonClick}>+</button>
    </>
  );
}

function C({ number }) {
  return (
    <div>
      {number} <D />
    </div>
  );
}

const D = memo(() => {
  return <>리액트 재밌다!</>;
});
```

그러면 D는 리렌더링되지 않는다.
