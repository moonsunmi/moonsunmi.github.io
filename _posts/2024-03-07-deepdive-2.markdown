---
layout: post
title: "React deep dive) 함수와 클래스"
date: 2024-03-07 12:18:07 +0900
tags: deepdive
---

###### \<모던 리액트 Deep Dive\>의 내용을 제가 이해한 바로 다시 정리한 글입니다.

## 함수

함수란 특정 작업을 실행 단위로 만들어둔 블록을 말한다.

리액트의 컴포넌트를 만드는 함수는 `props` 매개변수를 한 개 전달 받는다는 것과 JSX를 반환한다는 특징이 있다.

이런 건 문(statement).

```
function handleClick() {
    setCounter((prev) => prev + 1);
}
```

다음과 같은 건 표현식이다.

```
const DeepComponent = memo((props: DeepProps) => {
  useEffect(() => {
    console.log("Deepcomponent has been rendered.");
  });
  return <h1>{props.counter.counter}</h1>;
});
```

일급 객체란, 적용 가능한 연산을 모두 지원하는 객체. 자바스크립트에서 함수는 일급 객체이다.

자바스크립트는 함수 선언문이 마치 코드 맨 앞단에 작성된 것처럼 작동한다. 이럴 수 있는 이유는 함수에 대한 선언을 실행 전에 메모리에 등록하기 때문인데, 이를 호이스팅이라 한다.

함수 표현식에서 또한 호이스팅이 일어나기는 하는데, 변수 값이 undefined로 초기화된다.

화살표 함수의 이점 중 하나는 `this`를 사용하기 좋다는 점이다. 자바스크립트에서 `this`는 자신이 속한 객체나, 자신이 생성할 인스턴스를 가리킨다. 자신이 속한 객체를 나타낼지, 자신이 생성할 인스턴스를 나타낼지는 함수가 호출될 때 정해진다.

그래서 호출되기 전에 `this`를 사용할 경우 참조 에러(ReferenceError)가 발생한다.

하지만 화살표 함수는 함수 자체의 바인딩을 가지지 않는다. 자신만의 독립적인 `this` 값을 가지지 않고, 자신의 외부 범위(상위 스코프)로부터 `this` 값을 상속 받는다.

그래서 화살표 함수의 `this` 값은 그 함수를 감싼 범위의 `this` 값과 같아진다.

### 즉시 실행 함수

선언과 동시에 딱 한 번만 실행되는 함수다. 스코프를 구분하기 위해서 쓰기도 하는데, 딱 한 번만 실행되는 특성을 살려 웹 페이지가 로드될 때 사용자의 ID를 가져오는 것 등 초기화 코드를 작성하기에도 유용하다.

### 고차함수

고차 함수는 함수를 인자로 받거나 새로운 함수를 반환하는 역할을 한다. 이게 가능한 이유는 자바스크립트 함수가 인자로 전달도 가능하고, 반환도 가능한 일급 객체이기 때문이다. 함수를 인자로 받기만 해도, 반환을 함수로 하기만 해도, 함수를 인자로 받고 함수를 반환해도 고차 함수에 속한다.

자주 사용하는 `map`도 함수 형태의 인자를 받으니 고차 함수이다.

```
const doubleArray = [1, 2, 3].map((item) => {return item * 2})
```

### 좋은 함수 만들기

함수를 만들 때, 부수효과가 적도록 만든다. 부수효과가 없는 게 순수함수. 가능하면 순수 함수로 만드는 게 좋다.

리액트 입장에서는 `useEffect`를 줄이는 게 부수효과를 줄이는 방법 중 하나가 된다.

`useEffect`의 콜백 함수에 이름을 붙여주면, 가독성을 좋게 할 수 있다.

## 클래스

javascript는 프로토 타입 기반 언어이다. 모든 객체가 메서드와 속성을 상속받기 위한 프로토 타입 객체를 가지고 있다. 프로토 타입 객체 또한 상위 프로토 타입 객체로부터 상속 받을 수도 있다.

상속되는 속성과 메서드들은 객체의 생성자의 `prototype`이라는 속성에 저장되어 있다.

### 인스턴스 메서드

클래스 내부에서 선언한 메서드를 말한다. 자바스크립트의 `prototype`에 선언되므로 프로토타입 메서드라고 하기도 한다.

클래스 안에서 선언된 메서드를 인스턴스가 이용할 수 있는 이유는 이 인스턴스 메서드가 `prototype`에 선언되어 있기 때문이다.

```
const myCar = new Car('자동차')
Object.getPrototypeOf(myCar) // {constructor: f, hello: f}
```

`Car` 클래스의 인스턴스 메서드를 다음과 같이 따로 적어주는 것과 같게 되는 것이다.

```
function Car(){}
Car.prototype.hello = function() {console.log('hello');};
```

### 프로토타입 체이닝

이렇게 인스턴스가 메서드를 호출할 때, `prototype`에 저장되어 있는 메서드를 찾아 실행해주는 걸 프로토타입 체이닝이라고 한다.

만약 해당 객체의 `prototype`에 호출하려는 메서드가 없다면, 프로토타입의 프로토타입을 확인한다. 이런 방식으로 계속 해 나가다 보면 `Object` 객체까지 갈 수 있다.

프로토타입의 프로토타입을 알아내는 방법은 `prototype`에 지정되어 있는, `constructor`를 통해 프로토타입을 알아내고, 그 프로토타입의 `prototype` 값을 얻는 것이다.

### 정적 메서드

정적 메서드는 내부의 `this`가 클래스 자신을 가리킨다.

객체를 생성하지 않아도 접근 가능하기 때문에 전역에서 사용하는 유틸 함수를 쓸 때 정적 메서드 형태로 많이 활용한다.

### 상속

기존의 클래스를 상속 받아서 자식 클래스를 기반으로 확장하는 것. `extends` 키워드로 사용
